# 数

## Hello... Maths?

如果我没有搞错的话，这应该是你看到的，这个系列教程的第一篇。如果这不是你看的第一篇编程教程的话，你可能会感到奇怪，为什么一上来就从数开始，而不是一些老生常谈的——Hello World——又名“你好，世界”——之类的东西。

这是有原因的。

从Hello World讲起，根据维基百科的说法，起源于1972年，贝尔实验室的《A Tutorial Introduction to the Language B》（B语言教程式介绍）。作为一个普通的、简单的程序——也就是在控制台中打印出Hello World——他起到了示范一个语言如何工作，并且便于学习者在配置完环境之后验证配置是否正确的效果。

（如果上面这句话中的很多术语令你感到困惑，请原谅，因为这是我故意的。XD）

除此之外，在许多面向初学者的教程中，运行Hello World还起了“引起读者兴趣”的作用——至少语文的高考试卷会要求你这么作答。当然，是否有效又是一说。

然而从我的角度，我并不认为一本现代的（本篇写就于2018年）编程教程，还需要以Hello World开始。一方面是因为这篇教程（如果你有好好看前言的话）并不以讲授某种特定编程语言为终极目的，因而无需用某种示例程序来展示该语言的语法；而另在引起读者兴趣的另一方面，Hello World又早已落后于时代了。至少在互动性和趣味性上，无论是Scratch这种可视化编程工具，或者是诸如codecombat、Minecraft Education（我的世界教育版）等等写程序来控制角色移动、战斗的网站，都比在黑框框里输出干巴巴的一行字要来的强得多。

作为替代，我选择了从数开始讲起，就像小学数学的第一课就要介绍数字那样。

## 什么是数？

> 什么是数？数从哪里来？数要到哪里去？ ——哲学三连

为什么从数开始讲呢？如果你熟悉一些辩论中的话术技巧的话，你一定会说，我们先得弄清楚什么是数。这是一个好问题。

让我们先忘掉这是一篇编程教程，让我们打开计算器——windows用户可以按win+R然后输入calc然后按回车——或者用我们页面上的这个计算器，输入一些简单的算式……

[计算器]

如果你不方便打字的话，直接点下面算式旁的“运行”按钮也行：

```
3+5
```

```
2*6
```

```
4-9
```

```
5/7
```

让我们先假设你会做10以内的四则运算，那么你应该能验证，算式输出的结果正是你小学数学老师会告诉你的那样。

当然，复杂一些的算式也完全没有问题，比如：

```
(3+2)*14/10
```

```
1-(2-3)*6
```

那么恭喜你，你学会了编程！

——哦不，你学会的是使用计算器。

你可以继续举一反三下去，把一位数改成三位数，多加几个括号和加减乘除。你认为你输入的任何算式都将在我们的计算器上得到和数学相同的结果，直到你在计算一些奇怪的算式时发现了例外。在这里，为了节省大家的时间，我们已经列出了几个例外情况：

```
0.1+1-1
```

```
123456789123456789+1
```

——这可怪了！

`0.1+1-1`，小学生都知道应该是0.1，为什么这个蠢蠢的计算器竟然告诉我是`0.10000000000000009`？

`123456789123456789`加上1，肯定应该是变大才对，怎么反倒变小成了`123456789123456780`？

这到底是人性的毁灭，还是道德的沦丧？

——不，都不是。这就是数。但这不是普通的数，这是计算机里的数。

### 习题

1. 教会你正在上小学二年级的侄子用计算器检查数学作业。（但是一定要先自己完成一遍！）
2. 找找和上面的两个“错误”算式类似的式子，验证他们的结果确实是“错误”的。

## 我家电脑有够烦！

让我们再问一个差不多的问题：什么是计算机（电脑）？

左边的学渣起立回答道：电脑就是一个**游戏机**！

右边的学霸起立回答道：胡说八道！电脑明明是一个**图灵机**！

中间的学神阴阴一笑，起立回答道：你们还是拿衣服啊！电脑不过是一个**冯诺依曼架构下的通用图灵机**罢了！

老师（我）摆了摆手，示意同学们坐下，道：你们说的都对，但也都不对。我们现在用的电脑，都不是完整的图灵机，因为它并不具有无限的存储空间。或者说，宇宙中本来就不可能存在拥有无限存储空间的机器，因为宇宙中的物质总量有限，这些物质所能承载的信息也有限。

坐在靠窗倒数第二排的你，瑟瑟发抖。

---

那么这和我们要说的东西——计算机中的数——有什么关系呢？

关系就在于：计算机中的数，受到计算机空间（以及能够用于计算的时间）的有限性的局限，和数学意义上的数是有区别的。或者说，为了在成本能够接受的范围内，计算出有意义的结果，赋予计算机中每个数的存储空间是有限的。

展开来说主要有两点：

第一点，计算机中的数有上限，太大的数要么无法储存，要么就会丢失精度，比如上面的`123456789123456789+1`，实际上你甚至都不用加1，光是输入`123456789123456789`，就会发现输出的结果是`123456789123456780`，这正是因为这个数太大了，存储不下，只能把最后面的一位东西丢掉。

第二点，计算机中的数有下限，不过这个下限不是负数的下限，而是最接近于0的数的下限。比如你计算一下`1/7`，你会得到`0.14285714285714285`，但是`7分之1`明明就是`0.142857142857......`，怎么没输出几位就停下来了？你可以再计算一下`0.14285714285714285-1/7`，然后发现得到的结果就是一个0，因为对于计算机来说，`0.14285714285714285`和`7分之1`之间的差距实在太小了，计算机无法分辨，就把他们当作是一回事了。

你可能会说，这计算机怎么这么麻烦！你可能会嫌他笨，一个`7分之1`，只要存储为`0.142857循环`，不就不会损失任何精度了吗？一个`123456789123456789`，为什么就不知道去存储成`两个1到9拼起来`呢？

但是这在很多时候正是相当有用的，因为`7分之1`可以精确存储，那圆周率`pi`呢？这可是无限不循环的无理数，又该如何存储呢？正是这种不精确、这种有限、这种工程上的妥协，带来了如今信息时代的辉煌，毕竟——用35位精度的圆周率值，来计算一个能把太阳系包起来的一个圆的周长，误差还不到质子直径的百万分之一。

不过终归，麻烦就在那儿，不会多也不会少。作为一个编程学习者，这是你必须克服的第一道难关，那就是理解计算机中的数和数学中的数的不同。

所以，继续读下去吧！你读得越多，对这个问题的理解也就越充分，克服难关也就越容易！继续吧！

### 习题

1. 试着解释“为什么`123456789123456789+1`也得到`123456789123456780`”？如果是`123456789123456789+10`呢？
2. 以上这两点，是否能解释`0.1+1-1`的结果？

## 冯虚御风（1）

> 浩浩乎，如冯虚御风，而不知其所止；飘飘乎，如遗世独立，羽化而登仙。
>     ——苏轼《前赤壁赋》

我现在要告诉你的是：实际上，上面的这两点，其实是同一件事。

先别急着打人。思考一个问题：为什么`123456789123456789`到了计算机里，就变成了`123456789123456780`？

我之前给了一个答案：因为计算机存储空间不足，赋予每个数的空间有限，但是你有没有想过，就算`123456789123456789`变成了`123456789123456780`，它该是18位它还是18位啊！用来存储的空间不是明明没有变少嘛！

聪明的你脱口而出：但是它丢掉了一个9，就可以少储存一位了呀！

很好。那么，`123456789123456789`，扔掉一个9以后，只剩下`12345678912345678`了，为什么计算机知道要在后面添一个0呢？

你的大脑飞速运转：因为他在丢掉一个9的同时，还额外存储了一个“要添1个0”的提示，这样计算机就知道该怎么做了。

我紧追不放：但是这样的话，`12345678912345678`是17位，“要添 `1`个0”又是1位，这不还是18位么！意义何在呢？

你胸有成竹：如果你原来不是`123456789123456789`而是`123456789123456789123456789123456789`，我也给你变成`12345678912345678`，然后要求计算机添`19`个0，我就把一个36位的东西变成了`17+2=19`位。并且无论你的数再怎么变长，只要在100个0以内，我都只需要19位就能存下来，这样就很有意义了呢~

我露出了欣慰的笑容：执行一下这个试试看吧~

```
123456789123456789123456789123456789
```

```
12345678912345678e+19
```

是不是一样的？

（好，中场休息，你可以喝口水，再看一遍上面这段对话，仔细想想看有没有道理）

---

（中场休息结束）

你可能已经发现了，`12345678912345678e+19`的意思就是“在`12345678912345678`后面添19个0”。这和你（假装是你好了）之前的设想一模一样。

你可能又发现了，上面两个算式输出的结果都是`1.2345678912345678e+35`，按照上面的说法，他就应该是“在`1.2345678912345678`后面添35个0”，不过这时“添XX个0”的说法并不正确，应该说的是“将`1.2345678912345678`的小数点往右移35位”。这个结果**显然**与“将`12345678912345678`的小数点往右移19位”是一回事。

（——喂喂，一个整数哪里来的小数点！——这个问题就留给聪明的你来解决吧~）

你可能还没有发现，这种“小数e+整数”的形式，和一种你在初中或者高中学过的东西有点类似。什么东西呢？就是——科学记数法。如果将`1.2345678912345678e+35`改写成`1.2345678912345678*10^35`，就要明显不少了。

我们给这种以类似“科学计数法”的形式表达的数起了个统称，叫做“**浮点数**”，英语`floating-point number`。（真是直白的翻译呢）

浮点，顾名思义，就是“**浮动的小数点**”，即在浮点数中，小数点的位置是浮动的。

还不理解？让我们再展开说一点好了。

不理解浮动的小数点，不如让我们先看看**固定的小数点**是什么样的。比如这样一个数：`123.321`，我们可以拍着胸脯说：

```
123.321 = 1*10^2 + 2*10^1 + 3*10^0 + 3*10^(-1) + 2*10^(-2) + 1*10^(-3)
```

绝对不会有一点问题。为什么呢？因为我们知道，小数点前第一位数，就应该乘以1，小数点前第二位就应该乘以10，小数点后第二位就应该乘以1/100，所有这些加起来，和原本的数肯定一样。

那么对`12332.1`，即`123.321*10^2`，这个结果还成立吗？即：

```
123.321*10^2 = 1*10^2 + 2*10^1 + 3*10^0 + 3*10^(-1) + 2*10^(-2) + 1*10^(-3)
```

这个式子正确吗？显然不了。

要让他变正确，我们必须将后面的`10^2`乘进去，从而得到：

```
123.321*10^2 = 1*10^4 + 2*10^3 + 3*10^2 + 3*10^1 + 2*10^0 + 1*10^(-1）
```

如果我们将乘以`10^0`的那个数位后面当作小数点的话，这就相当于小数点处于后面的2和1之间了。

也就是说：原先的数在乘以后面的`10^n`之后，小数点的**等效**位置发生了变化，表现为小数点的位置在各个位置上浮动，这就是浮点数。

### 习题

1. 怎么“将`12345678912345678`的小数点往右移19位”？请验证其结果与“在`1.2345678912345678`后面添35个0”相同。
2. “`1.23e-5`”是什么意思？猜猜看！
3. 两个浮点数要怎么相加、相减、相乘、相除？想不出来也没关系哦~

## 冯虚御风（2）

让我们回到正题，为什么说“计算机中的数有上限”和“计算机中的数有下限”是一件事呢？

因为小数点在浮动的过程中，既可以往前（左）浮动，把数变大，也可以往后（右）浮动，把数变小。在科学记数法中，小数点前永远只能有一位，而且不能是0（除非这个数本身就是0），因此不管是`123456789123456780`还是`0.14285714285714285`，都可以化成浮点数的`1.2345678912345678e+17`和`1.4285714285714285e-1`的形式。如果你做了上节习题的第二题，应该会更容易理解一些。

如果我们把这两个浮点数放在一起：

```
1.2345678912345678e+17
1.4285714285714285e-1
```

我们会发现一件很有趣的事：这两个数小数点后的位数是相同的！这不是巧合（当然如果你算一下`5/7`的话会发现小数位数少了一位，这个原因日后再说），这正是浮点数的精髓所在：

无论是很大的数还是很小的数，都可以化为同样的形式，并且为此提供相同程度的精度。设想一下，如果没有浮点数，你要在同一个系统中使用上面这两个数，你就要保存小数点18位直到小数点后18位，足足36位的数据，所占用的空间直接翻了个倍。

因此，浮点数，以及浮点算术真正的意义就在于，它在保证了精度的同时，给予了相当广阔的数据范围可供使用。

那么为什么`0.14285714285714285-1/7`会得到0呢？原因也很简单：计算机不是不想把`1/7`精确地计算出来，但是它算着算着，算到`0.142857142857142857`的时候，发现18位已经到了，就把最后的7和后面不管还有没有的其他位数一股脑儿扔掉，就剩下一个`0.14285714285714285`，再一减，bingo！这不是一模一样么！

---

最后我们需要了解一下浮点算术的大致原理。

需要注意到的是，在我们的计算器中，我们输入的数往往并不是标准的浮点数（以`a.bcd...e+X`形式表达），而在计算中必须**先**将它们转换为浮点数，再进行计算。

在之前的习题中，你可能会困惑的是：`123456789123456789+1`得到`123456789123456790`，就算因为精度丢掉一位也应该得到`123456789123456790`而不是`123456789123456780`。其原因就在于，在对你输入的`123456789123456789`进行任何计算**之前**，他就已经被转换成了`123456789123456780`，后面的9已经被扔掉了。

对于乘法和除法来说，由于浮点数和科学记数法是一回事，比如我们将`123456789123456780`和`0.14285714285714285`相乘，我们就可以：

```
  123456789123456780 *         0.14285714285714285
= 1.2345678912345678 * 10^17 * 1.4285714285714285 * 10^(-1)
= 1.7636684160493826 * 10^16
= 17636684160493826
```

甚至我们都无需将那个`10^16`乘进去，直接保留`1.7636684160493826e+16`，这个浮点数就是乘法的结果了。

加法和减法则要复杂一些。在计算加减法的时候，我们需要首先将科学记数法的小数点对齐，然后再进行加减，最后在将结果表示为科学记数法的形式，比如：

```
  1.2345 * 10^2 + 1.2345 * 10^1
= 12.345 * 10^1 + 1.2345 * 10^1
= (12.345 + 1.2345) * 10^1
= 13.5795 * 10^1
= 1.35795 * 10^2
```

或者更形象一些：

```
    1.2345  * 10^2
 +  1.2345  * 10^1
-------------------
 = 12.345   * 10^1
 +  1.2345  * 10^1
-------------------
 = 13.5795  * 10^1
-------------------
 =  1.35795 * 10^2
```

大致如此。

至此，浮点数已经大致介绍完了，大家感觉如何呢？不过这只是一个小坑，之前还留了两个大坑没填，大家还记得是什么坑吗？不过，请不要担心、不要害怕，因为只要你慢慢读下去，一点一点地去尝试理解、接受——地狱就会降临。

（开玩笑的！）

### 习题

1. 浮点数的除法和减法，该怎么计算呢？
2. 用浮点数的加法计算`123456789123456789+1`和`123456789123456789+10`的结果，和之前的结果相同吗？

## ガヴリールが一人

> ガヴリールが一人、ガヴリールが二人、ガヴリールが三人．．．
> 
> ——《ガヴリールの数え歌》

前面留了两个坑，一个是为什么`0.1+1-1`得到的是一个奇怪的`0.10000000000000009`，这一点用现在我们学到的知识暂时还无法解释。另一个则是前面我们说“太大的数要么无法储存，要么就会丢失精度”，浮点数是“丢失精度”的那种，那么什么是“无法储存”的那种呢？这便是这一节的内容了。

说那混沌初开啊，盘古一斧子下去，那气便裂成了两半。轻的向上浮上去，是为浮点数，重的向下沉下去，是为**整数**。

不过这个说法是错误的。（废话！）事实上，在计算机的世界里，两者不是同时出现，而是先有整数，后有浮点数，只是在数学的学习中，我们接触整数之后，很快就学到了有理数、无理数、实数，考试里也是实数用的比较多，因此更容易理解浮点数一些。

但是在计算机的上古时代并不是这样。因为进行整数运算的元件结构上比浮点数运算的元件要简单得多，因此也更早地得到运用。

那么，既然我们已经脱离了上古时代，有了浮点数了，是否还需要整数呢？

这个问题的答案相对比较复杂。

一方面，在一些现代的编程语言，如javascript（你并不需要知道这是什么）中，基本完全抛弃了整数，由语言本身决定实际上使用整数还是浮点数来存储和运算，对语言的使用者来说无需进行甄别。另一方面，浮点数运算在效率方面还是不如整数，而且对存储空间占用较大（这个说法不严谨），在一些对性能和空间要求比较高的程序中仍然需要使用整数而不是浮点数。

不过需要强调的一点是，我们**不可能**真正抛弃整数，至少在现有的计算机架构下不可能。哪怕在语言层面上隐藏了整数和浮点数的差距，在其内部也必定需要使用到整数的概念，**不可能**实现一种可堪大用的、不需要任何整数存在的计算机。

究其原因，根本上是因为我们的计算机是**离散**的。

---

离散——英语`discrete`——描述的是与“连续”所相对应的一种情形。对应到不同类型的数里面来，就是整数和小数（浮点数）。而每个计算机的学习者所必须了解的是，我们现有的**所有**计算机都是离散的。无论年代、架构、性能、系统。

如果你了解一点量子物理的话，你可能很容易就能理解离散的概念，那么你大可跳过这一段，也算省点时间。对于还未理解的其他人，希望下面的解释能给你一个清晰的印象。

在解释离散之前，我先要问：你知道什么是原子吗？

由于我假定你受过高中教育，我认为你至少应该知道原子是什么，并且在化学课中了解到原子不会增加也不会减少（除非进行核反应），更不会改变类型，只会改变位置。而原子这个词本身，其英语`atom`，源于希腊语`atomos`，意为“不可分割的”。在原子被发现的时候，人们相信它是世界上最小的物质，于是给了它这个名字。当然我们现在知道原子之下还有质子、中子，它们又能再分为夸克，不过这并不影响我们对“离散”概念的理解。

而离散，正是建立在这种**不可分割**的性质之上的。

《庄子·天下篇》中云：

> 一尺之棰，日取其半，万世不竭。

意思是一根一尺长的木棍，每天取走它的一半，千百年也不会取完。翻译成数学语言，就是0.5的n次方随着n的增大而减小，但只会不断接近0，永远不会到达0。这是因为实数是连续的，因为任意两个（不同的）实数之间一定还存在另一个实数，事实上我们只要取这两个实数的平均数即可。

而整数则是离散的。物理告诉我们，将木棍永远这么分下去，分到一个原子，就不能再分下去了（假定我们不至于为了分木棍去搞核反应），这和整数是类似的：当两个整数的差大于1时，他们之间肯定有别的整数，但当两个整数相邻——差为1——时，再怎么找也都无法在他俩之间找到别的整数了。

这便是离散的概念了。

生活中实际上充满了离散，比如我们在说硬币的时候，只可能说`1`枚或者`2`枚，绝不会说`1.5`枚硬币——倒不是因为破坏人民币违法，而是因为当硬币变成半枚时，它就已经失去了作为“硬币”的意义了，因为硬币也是一种**不可分割**的东西。

我们的大（duo）天使珈百璃也是一样的，只能一只两只地去数，如果非要数上1.5只的话，那就成了刘慈欣《诗云》中说的那样了。（疯狂玩梗)

为什么我们的计算机是离散的？在最初的图灵机的定义中，其所有可能的状态数量是有限的，因而它必定是离散的——如果连续的话，任取两个数中间必定还有第三个，永远也找不到尽头，肯定不会是有限的了。当然如今也有一些学者在讨论连续图灵机的可能性等一系列问题，不过这可就大大超出我们的讨论范畴了，在此不表。（其实是因为作者本人也不太懂）

---

计算机的离散性导致了，计算机中的大量操作都只能针对整数进行。

比如一个文件有`10KB`，也就是`10*1024=10240`个字节（`byte=B`），我可以取其中的第`10`个字节，也可以取第`11`个字节，但是第`10.5`个字节则毫无意义。（当然你非要各取一半拼起来的话，请告诉我怎么取第`10又3分之1`个字节）

当然我们可以用浮点数取模拟整数，比如我强行四舍五入，把`10.5`化成`11`之后再使用，不过这在效率和易用性上都无法和直接使用整数相比。

因此，在计算机中，整数是**一等公民**，一个稍微靠谱些的计算机（软硬件）系统都不可能脱离整数而存在。

### 习题

1. 事实上，号称连续的浮点数也是离散的，只不过其“原子”（不可分割的最小部分）太小，以至于我们一般达不到这么小的差距，因此总能在两个浮点数之间找到另一个浮点数。运用前面的知识，你能解释这之中的必然性吗？
2. 观看动画《珈百璃的堕落》。（食我安利啦！）（其实是因为这节没什么题目好出）

## 01001000 01000101 01001100 01001100

> ——老师，这串0和1是什么啊？
>
> ——是老师的祝福哦~
>
> ——哼！欺负我读书少！
>
> ——不然呢？（邪魅一笑）

**警告：以下内容带有大量主观观点且晦涩难懂，读者可就个人能力决定是否阅读。**

20世纪以来的信息革命主要基于两件事：图灵机和离散化。

图灵机提供了一个通用的计算模型，使得软件和硬件的区别成为了可能，大大降低了计算的成本——在此之前，不同目的的两台机器一定有着不同的构造，因此也必须为他们设计两份不同的图纸、开两条不同的产线，产生双倍的成本（快乐）。通用计算硬件能够适应工业化的大规模生产，按照边际成本递减效应大大降低单位成本。

离散化，首先是提供了数字化的可能性。冯诺依曼体系中的运算单元要求数据被首先存入计算机的存储空间，这就需要我们对于从其他设备中获得的模拟信号进行转换，而因为计算机的存储空间有限，便势必需要将连续的模拟信号进行离散化处理。

其次，数据的离散化、尤其是二进制的发展，提供了缩小信息处理尺度的可能性。处理模拟信号的电子元件的大小收到物理定律的限制，无法缩小太多，而当信号被二进制化为了1和0，只需要区分高电平和低电平时，便可以使用结构简单得多的电子元件——即三极管——来进行处理。事实上，从电子管电路到集成电路，到大规模集成电路，如今的晶体管尺度已经达到了10纳米上下。尺度的缩小带来的是能耗、散热、占地——或者说成本——的降低，以及可用性、便携性的提高。同时，尺度的缩小也降低了信息传递所需经过的距离，降低了耗时、提高了数据处理的效率。当然，如今的集成电路发展也即将达到极限，量子和相对论效应造成的误差使得尺度的进一步缩小遇到困难，这又是另一件事了。

——毕竟，在工业生产中，成本是第一位的。每一次工业革命的爆发，都意味着一次断崖式的成本下跌，信息革命自然也不例外。例如：由于人口的快速增长，美国的人口普查效率不断降低，1880年开展的人口普查直到1886年都未能完成，而在Herman Hollerith采用了自己发明的打孔计算机之后，1890年人口普查只用了几个月就全部完成，而且开销比预算低得多。顺带一提，此人后来创办的Computing-Tabulating-Recording Company（计算-制表-记录公司），便是现在IBM的前身。

---

因此我们说，整数最重要的性质是离散性，除此之外的则是均匀性和有界性。

均匀性指的是，在整数的存储范围内，数的密度始终是一样的。这与浮点数不同。

假定有一种浮点数只有3位精度，比如：

```
1.23e+2 = 123
1.23e-2 = 0.0123
```

显然，因为它只有三位精度，在那个`e+n`（称为**指数**）之前的部分只能有1000种可能——从`000`到`999`——甚至还要排除掉`000`，只剩999种可能性。嘉定`e+n`中`n`的范围是`-2~2`的话，我们可以在数轴上把所有的点都标记出来，化成一张图：

[图片]

我们可以看到，在数轴上，不同的区域的密度是完全不同的。指数越小的区域，密度越高，相邻两个数之间的距离也越小。

而整数则不同。如果把整数`0~999`在数轴上标记出来：

[图片]

可以看到的是，其密度在所有地方都是完全相同的，相邻两个数之间的距离永远为1。这使得整数更适合用于处理**值域中信息密度均匀**的数据。

这样说显得很抽象，我们可以举个例子。比如有一本非常非常大的字典，足足有10000页，然后你需要给这本字典编写一个索引，你会选择用什么来表示页码？是整数还是浮点数？

作为一个设问句，答案很显然应该是**整数**。因为字典的每一页的重要性都是相同的，没有必要给前十页的页码标上三位小数，而超过一千页的页面如果只给三位小数的话，一个`1.23e+3`可能对应从`1230`到`1239`的任何一页，显然也并不合适。

在字典页码这个问题上，值是页码，值域是`1~10000`。而因为每一页中包含的信息（大致上）相同，因而我们说它的“信息密度均匀”，合在一起，就是“**值域中信息密度均匀**”了。事实上这种“值域中信息密度均匀”的情况有很多，**几乎所有**用于表示“**索引**”（也就是可以用于去在一堆东西里面找到所需的那一个的值）的数都应该使用整数。

那么什么是有界性呢？

当你试图用浮点数存储`123456789123456789`的时候，最后的9会被舍弃掉，但是如果整数的话，就会——

——告诉你这个数太大了，我们存不了。

事实上，均匀性和有界性是相辅相成的。整数是均匀的，也就意味着它在数很大的时候也必须均匀地、一个一个地存储，而且数越大，每多一位需要的整数的个数也越多。从`10`到`100`只要90个整数，从`1000`到`10000`就需要9000个整数，这样下去计算机所提供的有限空间很快就会花完。

当然，并不是说浮点数就想存多大就能存多大的数，只是浮点数所能表达的最大数以及超出了绝大多数常见的需求，一般我们不考虑浮点数过大的情况；而相对地，整数的上限就要小得多，比如一个4字节的有符号整数（你不需要知道这是什么意思）所能表达的最大数是`2147483647`，约莫`21.5亿`，这个数字还是很容易在生活中碰到甚至超过的——比如双十一一天的销售额就远远超过了它。

整数的有界性的意义在于，在进行与整数有关的计算时，需要注意所用的数的数量级。当数量级接近这种整数所能存储的上限时，就需要小心不让它超出上限的范围。我们将超出上限的这种情况称为“**溢出**”，而一旦一个数有溢出的风险，就要采取相应的措施：或是更换更占据空间、但也上限更高的数据类型；或是直接换成浮点数；或是采取某些黑科技……

当然，现在的我们并不需要知道这么多，只需要把概念搞清楚，不要犯了错误自己都不知道即可。在[进阶篇]中，我们还会看到更多的骚操作，来解决各种或大或小的问题。

### 习题

1. 猜猜看，`2147483647`是怎么来的？要不要试试看加上一呢？
2. 骚年，你知道什么是**Stack Overflow**吗？偷偷告诉你，这里的**Overflow**就是**溢出**的意思哦~（虽然实际上并完全是一回事呢）

## 碎碎碎碎碎碎念

计算机中数的概念，讲到这里就差不多了，更进一步的知识会放在[进阶篇]中讲解。虽然在前言中也有说明，不过在此还是想强调一下，这个系列教程遵照的是一种“各取所需”的模式，并非每篇都必读，而是应该根据自己的目标、以及通向该目标的路径去进行学习。

另：作为本篇的结尾，在此对一些细节的、但无法整合到正文中的内容进行附加一些说明。钦此。（醒醒你不是皇上啊）

### 关于固定小数点

在盘古开天辟地的时候，我们将整数和浮点数并列，可能有同学就要问：之前不是说浮点数与什么——小数点固定的数——相对应，怎么就变成整数了呢？

首先，整数就是一种小数点固定的数——它没有那个`*10^n`的指数部分，整数的最后一位就是代表`1`，倒数第二位就代表`10`，当然实际上它也没有小数点。其次，那些属于小数点固定的数，但又不是整数的，往往使用整数除以一个固定的缩放比例来实现。比如银行业系统中的金钱精确到小数点后3位，往往就用一个整数除以`1000`来表示，在3位之后的部分则被尽数丢弃。

也就是说，虽然在一些量特别大的商品的单价可能低于`0.001元`，但是一定会有类似“最少0.001元”之类的说明——因为低于这个价格的话，银行甚至无法扣你的款，总不能把东西就这么免费送你吧~

### 关于整数和浮点数的选择

什么时候用整数？什么时候用浮点数？

在Javascript、以及许多弱类型语言中，这根本不是一个问题，因为你没得选。不过在大部分强类型语言中，我们往往需要做出这个选择。虽然讲到这里你可能不知道什么是弱类型什么是强类型，不过我认为还是有必要从一个定性的角度来给出回答。

首先是之前说了，**几乎**用作索引的数据都应该是整数，因为浮点数在此处毫无意义。生活中的“索引”无处不在，比如页码、火车车厢编号等等。需要强调的是，我这里的“索引”主要指的是“顺序数据结构”的索引，而不是什么百度出来的“数据库索引”。

没错，这又是一个生词，不过简单地说，几乎所有的“顺序数据结构”都和一本书长得差不多——它有一定数量的元素（页），每个元素拥有一个独立的编号（页码），每个元素都有确定的前/后元素（上一页/下一页），而且常常需要通过编号去获取该元素（翻书）。关于这些，在之后的数据结构教程中，你会看到更多的例子和解释，在此就不多说了。

其次，整数相对于浮点数还有着高效的优点。当你确定某种需求用整数和浮点数都能实现，而且不存在溢出之类的问题时，你应该选择整数。这种情况往往出现于一些简单的计算中，不过一旦计算的复杂性、数据精度、数据范围增大时，就可能需要仔细进行考量了。

需要指出的是，浮点数有着很高的精度，但是并不精确。浮点数能对一个运算提供很多有效数字，但是由于其“用离散模拟连续”的性质，一定会产生误差。虽然这个误差往往小到可以忽略，但是它往往会干扰一些本以为没有问题的逻辑判断。比如按照最早的那个例子，运行：（这里`==`的意思是判断是否相等）

```
0.1+1-1==0.1
```

你会得到一个`false`，即英语的“错误”，这在很多时候是出人意料的。你可能会发现，哪怕到这一篇的末尾，我们都无法从根本上解释这个问题的产生原因。具体的原因，以及解决这种问题的方法，要在[进阶篇]中才会讲到，而现在说这个的目的是，希望每一个读者能够意识到这个问题的存在，在遇到问题时知道去寻找解决方案而不是两眼一抹黑。

然后，浮点数由于其定义的特点，不存在特别小的浮点数。一般地，最小的浮点数一个也需要消耗4字节的空间，而整数则允许更小的数据类型存在。在存储空间紧张、整数能够解决问题、并且运算所需的数据范围确定在一个小范围内时，也可以选择使用小的整数类型进行计算。不过这并不一定有效，因为如今许多计算机中会采用一种名为“4字节对齐”技术，运用之后所有值都会占据至少4个字节，也就不存在存储空间的优势了。

最后，整数由于其形式能够反映计算机底层的存储方式，能够做到一些浮点数无法做到的事。这些操作往往可用于提高效率、节省存储空间，或者与计算机底层交互等。关于这些，也都会在[进阶篇]中讲解，不过在这种情况下，整数已经一定程度上脱离了“数”的概念，更接近一种“数据”的意思了。对于没有这种需求的读者，不必了解页无伤大雅。

### 二进制

上一节的标题`01001000 01000101 01001100 01001100`实际上是二进制编码，换成十进制数是`72 69 76 76`，也就是`HELL`的ASCII编码（又是生词！）。之前说“地狱就会降临”，大体如此。

我之前也提到说，离散化带来的二进制是现代计算机系统的基石之一，从我的角度，我建议所有有志学习编程的人都去了解一下二进制。虽然如此，我还是将二进制放在了进阶篇中，原因有三：

1. 我认为二进制虽然重要，但是并非**必要**，它自然能够帮助对计算机底层有一个深入的了解，但是如果从更抽象的角度出发，则二进制也不过是一种计算机实现中的细节罢了。
2. 二进制还是数学性比较强，如果不和一些骚操作放在一起讲的话未免索然无味，放在最开头的第一篇容易让人心生厌倦，不如移植进阶篇中系统性地讲解，效果也会更好些。
3. 我个人推荐一本书：[《编码——隐匿在计算机软硬件背后的语言》](https://book.douban.com/subject/4822685/)，这本书用生动的语言，详实地讲述了“编码”这一概念的发展史，颇为有趣，也比我在此费上大量口舌来的更有效些。

当然，对于那些想要进一步了解的读者，我仍然推荐去读一读进阶篇，哪怕只了解其中的二进制部分也不错。毕竟，二进制是计算机行业最重要的梗之一。毕竟，不学二进制的话，你可能永远也不知道为什么`0.1+1-1`得到的是那么一个怪数字。（笑）

## 总习题

让我们来快乐地复习吧!

1. 计算：`35 / (5 + 4.9) - 3.456e+2`。
2. 为什么浮点数的指数用的是`e`？`e`不是自然对数的底吗？考验你英语水平的时候到了！
3. 除了索引，还有哪些“值域内信息密度均匀”的例子呢？
4. 思考题：有整数，有实数（浮点数），分数（有理数）去哪里了！为什么计算机不内置分数的计算硬件呢？你能解释这个现象吗？
