# 数

## Hello... Maths?

如果我没有搞错的话，这应该是你看到的，这个系列教程的第一篇。如果这不是你看的第一篇编程教程的话，你可能会感到奇怪，为什么一上来就从数开始，而不是一些老生常谈的——Hello World——又名“你好，世界”——之类的东西。

这是有原因的。

从Hello World讲起，根据维基百科的说法，最早是从1972年，贝尔实验室的一本《A Tutorial Introduction to the Language B》开始的。作为一个普通的、简单的程序——也就是在控制台中打印出Hello World——他起到了示范一个语言如何工作，并且便于学习者在配置完环境之后验证配置正确的效果。

（如果上面这句话中的很多术语令你感到困惑，请原谅，因为这是我故意的。）

除此之外，在许多面向初学者的教程中，运行Hello World还起了“引起读者兴趣”的作用——至少语文的高考试卷会要求你这么作答。当然，是否有效又是一说。

然而从我的角度，我并不认为一本现代的（本篇写就于2018年）编程教程，还需要以Hello World开始。一方面是因为这篇教程（如果你有好好看前言的话）并不以讲授某种特定编程语言为终极目的，因而无需用某种示例程序来展示该语言的语法，而另在引起读者兴趣的另一方面，Hello World又早已落后于时代了。至少在互动性和趣味性上，无论是Scratch这种可视化编程工具，或者是诸如codecombat、Minecraft Education（我的世界教育版）等等写程序来控制角色移动、战斗的平台，都比在黑框框里输出干巴巴的一行字要来的强得多。

作为替代，我选择了从数开始讲起，就像小学数学的第一课就要介绍数字那样。

## 什么是数？

> 什么是数？数从哪里来？数要到哪里去？ ——哲学三连

那么为什么从数开始讲呢？如果你熟悉一些辩论中的话术技巧的话，你一定会说，我们先得弄清楚什么是数。这是一个好问题。

让我们先忘掉这是一篇编程教程，让我们打开计算器——windows用户可以按win+R然后输入calc然后按回车——或者用我们页面上的这个计算器，输入一些简单的算式……

[计算器]

如果你不方便打字的话，直接点下面算式旁的“运行”按钮也行：

```
3+5
```

```
2*6
```

```
4-9
```

```
5/7
```

让我们先假设你会做10以内的四则运算，那么你应该能验证，算式输出的结果正是你小学数学老师会告诉你的那样。

当然，复杂一些的算式也完全没有问题，比如：

```
(3+2)*14/10
```

```
1-(2-3)*6
```

那么恭喜你，你学会了编程！

——哦不，你学会的是使用计算器。

你可以继续举一反三下去，把一位数改成三位数，多加几个括号和加减乘除。你认为你输入的任何算式都将在我们的计算器上得到和数学相同的结果，直到你在计算一些奇怪的算式时发现了例外。在这里，为了节省大家的时间，我们已经列出了几个例外情况：

```
0.1+1-1
```

```
123456789123456789+1
```

——这可怪了！

`0.1+1-1`，小学生都知道应该是0.1，为什么这个蠢蠢的计算器竟然告诉我是`0.10000000000000009`？

`123456789123456789`加上1，肯定应该是变大才对，怎么反倒变小成了`123456789123456780`？

这到底是人性的毁灭，还是道德的沦丧？

——不，都不是。这就是数。但这不是普通的数，这是计算机里的数。

### 习题

1. 教会你正在上小学二年级的侄子用计算器检查数学作业。（但是一定要先自己完成一遍！）
2. 找找和上面的两个“错误”算式类似的式子，验证他们的结果确实是“错误”的。

## 我家电脑有点烦！

让我们再问一个差不多的问题：什么是计算机（电脑）？

左边的学渣起立回答道：电脑就是一个**游戏机**！

右边的学霸起立回答道：胡说八道！电脑明明是一个**图灵机**！

中间的学神阴阴一笑，起立回答道：你们还是拿衣服啊！电脑不过是一个**冯诺依曼架构下的通用图灵机**罢了！

老师（我）摆了摆手，示意同学们坐下，道：你们说的都对，但也都不对。我们现在用的电脑，都不是完整的图灵机，因为它并不具有无限的存储空间。或者说，宇宙中本来就不可能存在拥有无限存储空间的机器，因为宇宙中的物质总量有限，这些物质所能承载的信息也有限。

坐在靠窗倒数第二排的你，瑟瑟发抖。

---

那么这和我们要说的东西——计算机中的数——有什么关系呢？

关系就在于：计算机中的数，受到计算机空间（以及能够用于计算的时间）的有限性的局限，和数学意义上的数是有区别的。或者说，为了在成本能够接受的范围内，计算出有意义的结果，赋予计算机中每个数的存储空间是有限的。

展开来说主要有两点：

第一点，计算机中的数有上限，太大的数要么无法储存，要么就会丢失精度，比如上面的`123456789123456789+1`，实际上你甚至都不用加1，光是输入`123456789123456789`，就会发现输出的结果是`123456789123456780`，这正是因为这个数太大了，存储不下，只能把最后面的一些东西丢掉。

第二点，计算机中的数有下限，不过这个下限不是负数的下限，而是最接近于0的数的下限。比如你计算一下`1/7`，你会得到`0.14285714285714285`，但是`7分之5`明明就是`0.142857142857......`，怎么没输出几位就停下来了？你可以再计算一下`0.14285714285714285-1/7`，然后发现得到的结果就是一个0，因为对于计算机来说，`0.14285714285714285`和`7分之1`之间的差距实在太小了，计算机无法分辨，就把他们当作是一回事了。

你可能会说，这计算机怎么这么麻烦！你可能会嫌他笨，一个`7分之1`，只要存储为`0.142857循环`，不就不会损失任何精度了吗？一个`123456789123456789`，为什么就不知道去存储成`两个1到9拼起来`呢？

但是这在很多时候正是相当有用的，因为`7分之1`可以精确存储，那圆周率`pi`呢？这可是无限不循环的无理数，又该如何存储呢？正是这种不精确、这种有限、这种工程上的妥协，带来了如今信息时代的辉煌，毕竟——用35位精度的圆周率值，来计算一个能把太阳系包起来的一个圆的周长，误差还不到质子直径的百万分之一。

不过终归，麻烦就在那儿，不会多也不会少。作为一个编程学习者，这是你必须克服的第一道难关，那就是理解计算机中的数和数学中的数的不同。

所以，继续读下去吧！你读得越多，对这个问题的理解也就越充分，克服难关也就越容易！继续吧！

### 习题

1. 解释“为什么`123456789123456789+1`也得到`1234567891213456780`”？如果是`123456789123456789+10`呢？
2. 以上这两点，是否能解释`0.1+1-1`的结果？

## 冯虚御风（1）

> 浩浩乎，如冯虚御风，而不知其所止；飘飘乎，如遗世独立，羽化而登仙。
>     ——苏轼《前赤壁赋》

我现在要告诉你的是：实际上，上面的这两点，其实是同一件事。

先别急着打人。思考一个问题：为什么`123456789123456789`到了计算机里，就变成了`123456789123456780`？

我之前给了一个答案：因为计算机存储空间不足，赋予每个数的空间有限，但是你有没有想过，就算`123456789123456789`变成了`123456789123456780`，它该是18位它还是18位啊！用来存储的空间不是明明没有变少嘛！

聪明的你脱口而出：但是它丢掉了一个9，就可以少储存一位了呀！

很好。那么，`123456789123456789`，扔掉一个9以后，只剩下`12345678912345678`了，为什么计算机知道要在后面添一个0呢？

你的大脑飞速运转：因为他在丢掉一个9的同时，还额外存储了一个“要添1个0”的提示，这样计算机就知道该怎么做了。

我紧追不放：但是这样的话，`12345678912345678`是17位，“要添 `1`个0”又是1位，这不还是18位么！意义何在呢？

你胸有成竹：如果你原来不是`123456789123456789`而是`123456789123456789123456789123456789`，我也给你变成`12345678912345678`，然后要求计算机添`19`个0，我就把一个36位的东西变成了`17+2=19`位。并且无论你的数再怎么变长，只要在100个0以内，我都只需要19位就能存下来，这样就很有意义了呢~

我露出了欣慰的笑容：执行一下这个试试看吧~

```
123456789123456789123456789123456789
```

```
12345678912345678e+19
```

是不是一样的？

（好，中场休息，你可以喝口水，再看一遍上面这段对话，仔细想想）

---

（中场休息结束）

你可能已经发现了，`12345678912345678e+19`的意思就是“在`12345678912345678`后面添19个0”。这和你（假装是你好了）之前的设想一模一样。

你可能又发现了，上面两个算式输出的结果都是`1.2345678912345678e+35`，按照上面的说法，他就应该是“在`1.2345678912345678`后面添35个0”，不过这时“添XX个0”的说法并不正确，应该说的是“将`1.2345678912345678`的小数点往右移35位”。这个结果**显然**与“将`12345678912345678`的小数点往右移19位”是一回事。

（——喂喂，一个整数哪里来的小数点！——这个问题就留给聪明的你来解决吧~）

你可能还没有发现，这种“小数e+整数”的形式，和一件初中或者高中学到的东西有点类似。什么东西呢？就是——科学记数法。如果将`1.2345678912345678e+35`改写成`1.2345678912345678*10^35`，就要明显不少了。

我们给这种以类似“科学计数法”的形式表达的数起了个统称，叫做“**浮点数**”，英语floating-point number。（真是直白的翻译呢）

浮点，顾名思义，就是“**浮动的小数点**”，即在浮点数中，小数点的位置是浮动的。

还不理解？让我们再展开说一点好了。

不理解浮动的小数点，不如让我们先看看**固定的小数点**是什么样的。比如这样一个数：`123.321`，我们可以拍着胸脯说：

```
123.321 = 1*10^2 + 2*10^1 + 3*10^0 + 3*10^(-1) + 2*10^(-2) + 1*10^(-3)
```

绝对不会有一点问题。为什么呢？因为我们知道，小数点前第一位数，就应该乘以1，小数点前第二位就应该乘以10，小数点后第二位就应该乘以1/100，所有这些加起来，和原本的数肯定一样。

那么对`12332.1`，即`123.321*10^2`，这个结果还成立吗？即：

```
123.321*10^2 = 1*10^2 + 2*10^1 + 3*10^0 + 3*10^(-1) + 2*10^(-2) + 1*10^(-3)
```

这个式子正确吗？显然不了。

要让他变正确，我们必须将他写成：

```
123.321*10^2 = 1*10^4 + 2*10^3 + 3*10^2 + 3*10^1 + 2*10^0 + 1*10^(-1）
```

也就是说：小数点前后第几位，应该乘以几，我们就不能直接确定了。换句话说，小数点的位置在各个位置上浮动，这就是浮点数。

### 习题

1. 怎么“将`12345678912345678`的小数点往右移19位”？请验证其结果与“在`1.2345678912345678`后面添35个0”相同。
2. “`1.23e-5`”是什么意思？猜猜看！
3. 两个浮点数要怎么相加、相减、相乘、相除？想不出来也没关系哦~

## 冯虚御风（2）

让我们回到正题，为什么说“计算机中的数有上限”和“计算机中的数有下限”是一件事呢？

因为小数点在浮动的过程中，既可以往前（左）浮动，把数变大，也可以往后（右）浮动，把数变小。在科学记数法中，小数点前永远只能有一位，而且不能是0（除非这个数本身就是0），因此不管是`123456789123456780`还是`0.14285714285714285`，都可以化成浮点数的`1.2345678912345678e+17`和`1.4285714285714285e-1`的形式。如果你做了上节习题的第二题，应该会更容易理解一些。

如果我们把这两个浮点数放在一起：

```
1.2345678912345678e+17
1.4285714285714285e-1
```

我们会发现一件很有趣的事：这两个数小数点后的位数是相同的！这不是巧合（当然如果你算一下`5/7`的话会发现小数位数少了一位，这个原因日后再说），这正是浮点数的精髓所在：

无论是很大的数还是很小的数，都可以化为同样的形式，并且为此提供相同程度的精度。设想一下，如果没有浮点数，你要在同一个系统中使用上面这两个数，你就要保存小数点18位直到小数点后18位，足足36位的数据，所占用的空间直接翻了个倍。

因此，浮点数，以及浮点算术真正的意义就在于，它在保证了精度的同时，给予了相当广阔的数据范围可供使用。

那么为什么`0.14285714285714285-1/7`会得到0呢？原因也很简单：计算机不是不想把`1/7`精确地计算出来，但是它算着算着，算到`0.142857142857142857`的时候，发现18位已经到了，就把最后的7和后面不管还有没有的其他位数一股脑儿扔掉，就剩下一个`0.14285714285714285`，再一减，bingo！这不是一模一样么！

最后我们需要了解一下浮点算术的大致原理。

对于乘法和除法来说，由于浮点数和科学记数法是一回事，比如我们将`123456789123456780`和`0.14285714285714285`相乘，我们就可以：

```
  123456789123456780 *         0.14285714285714285
= 1.2345678912345678 * 10^17 * 1.4285714285714285 * 10^(-1)
= 1.7636684160493826 * 10^16
= 17636684160493826
```

甚至我们都无需将那个`10^16`乘进去，直接保留`1.7636684160493826e+16`，这个浮点数就是乘法的结果了。

加法和减法则要复杂一些。在计算加减法的时候，我们需要首先将科学记数法的**指数**对齐，然后再进行加减，最后在将结果表示为科学记数法的形式，比如：

```
  1.2345 * 10^2 + 1.2345 * 10^1
= 12.345 * 10^1 + 1.2345 * 10^1
= (12.345 + 1.2345) * 10^1
= 13.5795 * 10^1
= 1.35795 * 10^2
```

大致如此。

至此，浮点数已经大致介绍完了，大家感觉如何呢？不过这只是一个小坑，之前还留了两个大坑没填，大家还记得是什么坑吗？不过，请不要担心、不要害怕，因为只要你慢慢读下去，一点一点地去尝试理解、接受，地狱就会降临。

（开玩笑的！）

### 习题

1. 浮点数的除法和减法，该怎么计算呢？
2. 用浮点数的加法计算`123456789123456789+1`和`123456789123456789+10`的结果，和之前的结果相同吗？

## 01001000 01000101 01001100 01001100

> ——老师，这串0和1是什么啊？
>
> ——是老师的祝福哦~
>
> ——哼！欺负我读书少！
>
> ——不然呢？（邪魅一笑）

前面留了两个坑，一个是为什么`0.1+1-1`得到的是一个奇怪的`0.10000000000000009`，这一点用现在我们学到的知识暂时还无法解释。另一个则是前面我们说“太大的数要么无法储存，要么就会丢失精度”，浮点数是“丢失精度”的那种，那么什么是“无法储存”的那种呢？这便是这一节的内容了。

说那混沌初开啊，盘古一斧子下去，那气便裂成了两半。轻的向上浮上去，是为浮点数，重的向下沉下去，是为**整数**。

不过这个说法是错误的。（废话！）事实上，在计算机的世界里，两者不是同时出现，而是先有整数，后有浮点数，只是在数学的学习中，我们接触整数之后，很快就学到了有理数、无理数、实数，考试里也是实数用的比较多，因此更容易理解浮点数一些。

但是在计算机的上古时代并不是这样。因为进行整数运算的元件结构上比浮点数运算的元件要简单得多，因此也更早地得到运用。

那么，既然我们已经脱离了上古时代，有了浮点数了，是否还需要整数呢？

这个问题的答案相对比较复杂。

一方面，在一些现代的编程语言，如javascript（你并不需要知道这是什么）中，基本完全抛弃了整数，或者由语言本身决定实际上使用整数还是浮点数来存储和运算，对语言的使用者来说无需进行甄别。另一方面，浮点数运算在效率方面还是不如整数，而且对存储空间占用较大（这个说法不严谨），在一些对性能和空间要求比较高的程序中仍然需要使用整数而不是浮点数。

不过这都不是我们讨论的核心。
