# 数

## Hello... Maths?

如果我没有搞错的话，这应该是你看到的，这个系列教程的第一篇。如果这不是你看的第一篇编程教程的话，你可能会感到奇怪，为什么一上来就从数开始，而不是一些老生常谈的——Hello World——又名“你好，世界”——之类的东西。

这是有原因的。

从Hello World讲起，根据维基百科的说法，起源于1972年，贝尔实验室的《A Tutorial Introduction to the Language B》（B语言教程式介绍）。作为一个普通的、简单的程序——也就是在控制台中打印出Hello World——他起到了示范一个语言如何工作，并且便于学习者在配置完环境之后验证配置是否正确的效果。

（如果上面这句话中的很多术语令你感到困惑，请原谅，因为这是我故意的。XD）

除此之外，在许多面向初学者的教程中，运行Hello World还起了“引起读者兴趣”的作用——至少语文的高考试卷会要求你这么作答。当然，是否有效又是一说。

然而从我的角度，我并不认为一本现代的（本篇写就于2018年）编程教程，还需要以Hello World开始。一方面是因为这篇教程（如果你有好好看前言的话）并不以讲授某种特定编程语言为终极目的，因而无需用某种示例程序来展示该语言的语法；而另在引起读者兴趣的另一方面，Hello World又早已落后于时代了。至少在互动性和趣味性上，无论是Scratch这种可视化编程工具，或者是诸如codecombat、Minecraft Education（我的世界教育版）等等写程序来控制角色移动、战斗的网站，都比在黑框框里输出干巴巴的一行字要来的强得多。

作为替代，我选择了从数开始讲起，就像小学数学的第一课就要介绍数字那样。

## 什么是数？

> 什么是数？数从哪里来？数要到哪里去？ ——哲学三连

为什么从数开始讲呢？如果你熟悉一些辩论中的话术技巧的话，你一定会说，我们先得弄清楚什么是数。这是一个好问题。

让我们先忘掉这是一篇编程教程，让我们打开计算器——windows用户可以按win+R然后输入calc然后按回车——或者用我们页面上的这个计算器，输入一些简单的算式……

[计算器]

如果你不方便打字的话，直接点下面算式旁的“运行”按钮也行：

```
3+5
```

```
2*6
```

```
4-9
```

```
5/7
```

让我们先假设你会做10以内的四则运算，那么你应该能验证，算式输出的结果正是你小学数学老师会告诉你的那样。

当然，复杂一些的算式也完全没有问题，比如：

```
(3+2)*14/10
```

```
1-(2-3)*6
```

那么恭喜你，你学会了编程！

——哦不，你学会的是使用计算器。

你可以继续举一反三下去，把一位数改成三位数，多加几个括号和加减乘除。你认为你输入的任何算式都将在我们的计算器上得到和数学相同的结果，直到你在计算一些奇怪的算式时发现了例外。在这里，为了节省大家的时间，我们已经列出了几个例外情况：

```
0.1+1-1
```

```
123456789123456789+1
```

——这可怪了！

`0.1+1-1`，小学生都知道应该是0.1，为什么这个蠢蠢的计算器竟然告诉我是`0.10000000000000009`？

`123456789123456789`加上1，肯定应该是变大才对，怎么反倒变小成了`123456789123456780`？

这到底是人性的毁灭，还是道德的沦丧？

——不，都不是。这就是数。但这不是普通的数，这是计算机里的数。

### 习题

1. 教会你正在上小学二年级的侄子用计算器检查数学作业。（但是一定要先自己完成一遍！）
2. 找找和上面的两个“错误”算式类似的式子，验证他们的结果确实是“错误”的。

## 我家电脑有够烦！

让我们再问一个差不多的问题：什么是计算机（电脑）？

左边的学渣起立回答道：电脑就是一个**游戏机**！

右边的学霸起立回答道：胡说八道！电脑明明是一个**图灵机**！

中间的学神阴阴一笑，起立回答道：你们还是拿衣服啊！电脑不过是一个**冯诺依曼架构下的通用图灵机**罢了！

老师（我）摆了摆手，示意同学们坐下，道：你们说的都对，但也都不对。我们现在用的电脑，都不是完整的图灵机，因为它并不具有无限的存储空间。或者说，宇宙中本来就不可能存在拥有无限存储空间的机器，因为宇宙中的物质总量有限，这些物质所能承载的信息也有限。

坐在靠窗倒数第二排的你，瑟瑟发抖。

---

那么这和我们要说的东西——计算机中的数——有什么关系呢？

关系就在于：计算机中的数，受到计算机空间（以及能够用于计算的时间）的有限性的局限，和数学意义上的数是有区别的。或者说，为了在成本能够接受的范围内，计算出有意义的结果，赋予计算机中每个数的存储空间是有限的。

展开来说主要有两点：

第一点，计算机中的数有上限，太大的数要么无法储存，要么就会丢失精度，比如上面的`123456789123456789+1`，实际上你甚至都不用加1，光是输入`123456789123456789`，就会发现输出的结果是`123456789123456780`，这正是因为这个数太大了，存储不下，只能把最后面的一位东西丢掉。

第二点，计算机中的数有下限，不过这个下限不是负数的下限，而是最接近于0的数的下限。比如你计算一下`1/7`，你会得到`0.14285714285714285`，但是`7分之1`明明就是`0.142857142857......`，怎么没输出几位就停下来了？你可以再计算一下`0.14285714285714285-1/7`，然后发现得到的结果就是一个0，因为对于计算机来说，`0.14285714285714285`和`7分之1`之间的差距实在太小了，计算机无法分辨，就把他们当作是一回事了。

你可能会说，这计算机怎么这么麻烦！你可能会嫌他笨，一个`7分之1`，只要存储为`0.142857循环`，不就不会损失任何精度了吗？一个`123456789123456789`，为什么就不知道去存储成`两个1到9拼起来`呢？

但是这在很多时候正是相当有用的，因为`7分之1`可以精确存储，那圆周率`pi`呢？这可是无限不循环的无理数，又该如何存储呢？正是这种不精确、这种有限、这种工程上的妥协，带来了如今信息时代的辉煌，毕竟——用35位精度的圆周率值，来计算一个能把太阳系包起来的一个圆的周长，误差还不到质子直径的百万分之一。

不过终归，麻烦就在那儿，不会多也不会少。作为一个编程学习者，这是你必须克服的第一道难关，那就是理解计算机中的数和数学中的数的不同。

所以，继续读下去吧！你读得越多，对这个问题的理解也就越充分，克服难关也就越容易！继续吧！

### 习题

1. 试着解释“为什么`123456789123456789+1`也得到`123456789123456780`”？如果是`123456789123456789+10`呢？
2. 以上这两点，是否能解释`0.1+1-1`的结果？

## 冯虚御风（1）

> 浩浩乎，如冯虚御风，而不知其所止；飘飘乎，如遗世独立，羽化而登仙。
>     ——苏轼《前赤壁赋》

我现在要告诉你的是：实际上，上面的这两点，其实是同一件事。

先别急着打人。思考一个问题：为什么`123456789123456789`到了计算机里，就变成了`123456789123456780`？

我之前给了一个答案：因为计算机存储空间不足，赋予每个数的空间有限，但是你有没有想过，就算`123456789123456789`变成了`123456789123456780`，它该是18位它还是18位啊！用来存储的空间不是明明没有变少嘛！

聪明的你脱口而出：但是它丢掉了一个9，就可以少储存一位了呀！

很好。那么，`123456789123456789`，扔掉一个9以后，只剩下`12345678912345678`了，为什么计算机知道要在后面添一个0呢？

你的大脑飞速运转：因为他在丢掉一个9的同时，还额外存储了一个“要添1个0”的提示，这样计算机就知道该怎么做了。

我紧追不放：但是这样的话，`12345678912345678`是17位，“要添 `1`个0”又是1位，这不还是18位么！意义何在呢？

你胸有成竹：如果你原来不是`123456789123456789`而是`123456789123456789123456789123456789`，我也给你变成`12345678912345678`，然后要求计算机添`19`个0，我就把一个36位的东西变成了`17+2=19`位。并且无论你的数再怎么变长，只要在100个0以内，我都只需要19位就能存下来，这样就很有意义了呢~

我露出了欣慰的笑容：执行一下这个试试看吧~

```
123456789123456789123456789123456789
```

```
12345678912345678e+19
```

是不是一样的？

（好，中场休息，你可以喝口水，再看一遍上面这段对话，仔细想想看有没有道理）

---

（中场休息结束）

你可能已经发现了，`12345678912345678e+19`的意思就是“在`12345678912345678`后面添19个0”。这和你（假装是你好了）之前的设想一模一样。

你可能又发现了，上面两个算式输出的结果都是`1.2345678912345678e+35`，按照上面的说法，他就应该是“在`1.2345678912345678`后面添35个0”，不过这时“添XX个0”的说法并不正确，应该说的是“将`1.2345678912345678`的小数点往右移35位”。这个结果**显然**与“将`12345678912345678`的小数点往右移19位”是一回事。

（——喂喂，一个整数哪里来的小数点！——这个问题就留给聪明的你来解决吧~）

你可能还没有发现，这种“小数e+整数”的形式，和一种你在初中或者高中学过的东西有点类似。什么东西呢？就是——科学记数法。如果将`1.2345678912345678e+35`改写成`1.2345678912345678*10^35`，就要明显不少了。

我们给这种以类似“科学计数法”的形式表达的数起了个统称，叫做“**浮点数**”，英语`floating-point number`。（真是直白的翻译呢）

浮点，顾名思义，就是“**浮动的小数点**”，即在浮点数中，小数点的位置是浮动的。

还不理解？让我们再展开说一点好了。

不理解浮动的小数点，不如让我们先看看**固定的小数点**是什么样的。比如这样一个数：`123.321`，我们可以拍着胸脯说：

```
123.321 = 1*10^2 + 2*10^1 + 3*10^0 + 3*10^(-1) + 2*10^(-2) + 1*10^(-3)
```

绝对不会有一点问题。为什么呢？因为我们知道，小数点前第一位数，就应该乘以1，小数点前第二位就应该乘以10，小数点后第二位就应该乘以1/100，所有这些加起来，和原本的数肯定一样。

那么对`12332.1`，即`123.321*10^2`，这个结果还成立吗？即：

```
123.321*10^2 = 1*10^2 + 2*10^1 + 3*10^0 + 3*10^(-1) + 2*10^(-2) + 1*10^(-3)
```

这个式子正确吗？显然不了。

要让他变正确，我们必须将后面的`10^2`乘进去，从而得到：

```
123.321*10^2 = 1*10^4 + 2*10^3 + 3*10^2 + 3*10^1 + 2*10^0 + 1*10^(-1）
```

如果我们将乘以`10^0`的那个数位后面当作小数点的话，这就相当于小数点处于后面的2和1之间了。

也就是说：原先的数在乘以后面的`10^n`之后，小数点的**等效**位置发生了变化，表现为小数点的位置在各个位置上浮动，这就是浮点数。

### 习题

1. 怎么“将`12345678912345678`的小数点往右移19位”？请验证其结果与“在`1.2345678912345678`后面添35个0”相同。
2. “`1.23e-5`”是什么意思？猜猜看！
3. 两个浮点数要怎么相加、相减、相乘、相除？想不出来也没关系哦~

## 冯虚御风（2）

让我们回到正题，为什么说“计算机中的数有上限”和“计算机中的数有下限”是一件事呢？

因为小数点在浮动的过程中，既可以往前（左）浮动，把数变大，也可以往后（右）浮动，把数变小。在科学记数法中，小数点前永远只能有一位，而且不能是0（除非这个数本身就是0），因此不管是`123456789123456780`还是`0.14285714285714285`，都可以化成浮点数的`1.2345678912345678e+17`和`1.4285714285714285e-1`的形式。如果你做了上节习题的第二题，应该会更容易理解一些。

如果我们把这两个浮点数放在一起：

```
1.2345678912345678e+17
1.4285714285714285e-1
```

我们会发现一件很有趣的事：这两个数小数点后的位数是相同的！这不是巧合（当然如果你算一下`5/7`的话会发现小数位数少了一位，这个原因日后再说），这正是浮点数的精髓所在：

无论是很大的数还是很小的数，都可以化为同样的形式，并且为此提供相同程度的精度。设想一下，如果没有浮点数，你要在同一个系统中使用上面这两个数，你就要保存小数点18位直到小数点后18位，足足36位的数据，所占用的空间直接翻了个倍。

因此，浮点数，以及浮点算术真正的意义就在于，它在保证了精度的同时，给予了相当广阔的数据范围可供使用。

那么为什么`0.14285714285714285-1/7`会得到0呢？原因也很简单：计算机不是不想把`1/7`精确地计算出来，但是它算着算着，算到`0.142857142857142857`的时候，发现18位已经到了，就把最后的7和后面不管还有没有的其他位数一股脑儿扔掉，就剩下一个`0.14285714285714285`，再一减，bingo！这不是一模一样么！

---

最后我们需要了解一下浮点算术的大致原理。

需要注意到的是，在我们的计算器中，我们输入的数往往并不是标准的浮点数（以`a.bcd...e+X`形式表达），而在计算中必须**先**将它们转换为浮点数，再进行计算。

在之前的习题中，你可能会困惑的是：`123456789123456789+1`得到`123456789123456790`，就算因为精度丢掉一位也应该得到`123456789123456790`而不是`123456789123456780`。其原因就在于，在对你输入的`123456789123456789`进行任何计算**之前**，他就已经被转换成了`123456789123456780`，后面的9已经被扔掉了。

对于乘法和除法来说，由于浮点数和科学记数法是一回事，比如我们将`123456789123456780`和`0.14285714285714285`相乘，我们就可以：

```
  123456789123456780 *         0.14285714285714285
= 1.2345678912345678 * 10^17 * 1.4285714285714285 * 10^(-1)
= 1.7636684160493826 * 10^16
= 17636684160493826
```

甚至我们都无需将那个`10^16`乘进去，直接保留`1.7636684160493826e+16`，这个浮点数就是乘法的结果了。

加法和减法则要复杂一些。在计算加减法的时候，我们需要首先将科学记数法的小数点对齐，然后再进行加减，最后在将结果表示为科学记数法的形式，比如：

```
  1.2345 * 10^2 + 1.2345 * 10^1
= 12.345 * 10^1 + 1.2345 * 10^1
= (12.345 + 1.2345) * 10^1
= 13.5795 * 10^1
= 1.35795 * 10^2
```

或者更形象一些：

```
    1.2345  * 10^2
 +  1.2345  * 10^1
-------------------
 = 12.345   * 10^1
 +  1.2345  * 10^1
-------------------
 = 13.5795  * 10^1
-------------------
 =  1.35795 * 10^2
```

大致如此。

至此，浮点数已经大致介绍完了，大家感觉如何呢？不过这只是一个小坑，之前还留了两个大坑没填，大家还记得是什么坑吗？不过，请不要担心、不要害怕，因为只要你慢慢读下去，一点一点地去尝试理解、接受——地狱就会降临。

（开玩笑的！）

### 习题

1. 浮点数的除法和减法，该怎么计算呢？
2. 用浮点数的加法计算`123456789123456789+1`和`123456789123456789+10`的结果，和之前的结果相同吗？

## ガヴリールが一人

> ガヴリールが一人、ガヴリールが二人、ガヴリールが三人．．．
> 
> ——《ガヴリールの数え歌》

前面留了两个坑，一个是为什么`0.1+1-1`得到的是一个奇怪的`0.10000000000000009`，这一点用现在我们学到的知识暂时还无法解释。另一个则是前面我们说“太大的数要么无法储存，要么就会丢失精度”，浮点数是“丢失精度”的那种，那么什么是“无法储存”的那种呢？这便是这一节的内容了。

说那混沌初开啊，盘古一斧子下去，那气便裂成了两半。轻的向上浮上去，是为浮点数，重的向下沉下去，是为**整数**。

不过这个说法是错误的。（废话！）事实上，在计算机的世界里，两者不是同时出现，而是先有整数，后有浮点数，只是在数学的学习中，我们接触整数之后，很快就学到了有理数、无理数、实数，考试里也是实数用的比较多，因此更容易理解浮点数一些。

但是在计算机的上古时代并不是这样。因为进行整数运算的元件结构上比浮点数运算的元件要简单得多，因此也更早地得到运用。

那么，既然我们已经脱离了上古时代，有了浮点数了，是否还需要整数呢？

这个问题的答案相对比较复杂。

一方面，在一些现代的编程语言，如javascript（你并不需要知道这是什么）中，基本完全抛弃了整数，由语言本身决定实际上使用整数还是浮点数来存储和运算，对语言的使用者来说无需进行甄别。另一方面，浮点数运算在效率方面还是不如整数，而且对存储空间占用较大（这个说法不严谨），在一些对性能和空间要求比较高的程序中仍然需要使用整数而不是浮点数。

不过需要强调的一点是，我们**不可能**真正抛弃整数，至少在现有的计算机架构下不可能。哪怕在语言层面上隐藏了整数和浮点数的差距，在其内部也必定需要使用到整数的概念，**不可能**实现一种可堪大用的、不需要任何整数存在的计算机。

究其原因，根本上是因为我们的计算机是**离散**的。

---

离散——英语`discrete`——描述的是与“连续”所相对应的一种情形。对应到不同类型的数里面来，就是整数和小数（浮点数）。而每个计算机的学习者所必须了解的是，我们现有的**所有**计算机都是离散的。无论年代、架构、性能、系统。

如果你了解一点量子物理的话，你可能很容易就能理解离散的概念，那么你大可跳过这一段，也算省点时间。对于还未理解的其他人，希望下面的解释能给你一个清晰的印象。

在解释离散之前，我先要问：你知道什么是原子吗？

由于我假定你受过高中教育，我认为你至少应该知道原子是什么，并且在化学课中了解到原子不会增加也不会减少（除非进行核反应），更不会改变类型，只会改变位置。而原子这个词本身，其英语`atom`，源于希腊语`atomos`，意为“不可分割的”。在原子被发现的时候，人们相信它是世界上最小的物质，于是给了它这个名字。当然我们现在知道原子之下还有质子、中子，它们又能再分为夸克，不过这并不影响我们对“离散”概念的理解。

而离散，正是建立在这种**不可分割**的性质之上的。

《庄子·天下篇》中云：

> 一尺之棰，日取其半，万世不竭。

意思是一根一尺长的木棍，每天取走它的一半，千百年也不会取完。翻译成数学语言，就是0.5的n次方随着n的增大而减小，但只会不断接近0，永远不会到达0。这是因为实数是连续的，因为任意两个（不同的）实数之间一定还存在另一个实数，事实上我们只要取这两个实数的平均数即可。

而整数则是离散的。物理告诉我们，将木棍永远这么分下去，分到一个原子，就不能再分下去了（假定我们不至于为了分木棍去搞核反应），这和整数是类似的：当两个整数的差大于1时，他们之间肯定有别的整数，但当两个整数相邻——差为1——时，再怎么找也都无法在他俩之间找到别的整数了。

这便是离散的概念了。

生活中实际上充满了离散，比如我们在说硬币的时候，只可能说`1`枚或者`2`枚，绝不会说`1.5`枚硬币——倒不是因为破坏人民币违法，而是因为当硬币变成半枚时，它就已经失去了作为“硬币”的意义了，因为硬币也是一种**不可分割**的东西。

我们的大（duo）天使珈百璃也是一样的，只能一只两只地去数，如果非要数上1.5只的话，那就成了刘慈欣《诗云》中说的那样了。（疯狂玩梗)

为什么我们的计算机是离散的？在最初的图灵机的定义中，其所有可能的状态数量是有限的，因而它必定是离散的——如果连续的话，任取两个数中间必定还有第三个，永远也找不到尽头，肯定不会是有限的了。当然如今也有一些学者在讨论连续图灵机的可能性等一系列问题，不过这可就大大超出我们的讨论范畴了，在此不表。（其实是因为作者本人也不太懂）

---

计算机的离散性导致了，计算机中的大量操作都只能针对整数进行。

比如一个文件有`10KB`，也就是`10*1024=10240`个字节（`byte=B`），我可以取其中的第`10`个字节，也可以取第`11`个字节，但是第`10.5`个字节则毫无意义。（当然你非要各取一半拼起来的话，请告诉我怎么取第`10又3分之1`个字节）

当然我们可以用浮点数取模拟整数，比如我强行四舍五入，把`10.5`化成`11`之后再使用，不过这在效率和复杂度上都无法和直接使用整数相比。

因此，在计算机中，整数是**一等公民**，一个稍微靠谱些的计算机（软硬件）系统都不可能脱离整数而存在。

### 习题

1. 事实上，号称连续的浮点数也是离散的，只不过其“原子”（不可分割的最小部分）太小，以至于我们一般达不到这么小的差距，因此总能在两个浮点数之间找到另一个浮点数。运用前面的知识，你能解释这之中的必然性吗？
2. 观看动画《珈百璃的堕落》。（食我安利啦！）

## 01001000 01000101 01001100 01001100

> ——老师，这串0和1是什么啊？
>
> ——是老师的祝福哦~
>
> ——哼！欺负我读书少！
>
> ——不然呢？（邪魅一笑）
